/*
 *  variablesregistry.cpp
 *  TGen Engine
 *
 *  Created by Peter Backman on 8/27/07.
 *  Copyright 2007 Peter Backman. All rights reserved.
 *
 */

#include "variablesregistry.h"
#include "file.h"
#include "filesystem.h"
#include <tgen_core.h>

TGen::Engine::VariablesRegistry::VariablesRegistry() {
	
}

TGen::Engine::VariablesRegistry::~VariablesRegistry() {
	
}

const TGen::Engine::Variable & TGen::Engine::VariablesRegistry::getVariable(const std::string & name) const {
	VariableMap::const_iterator iter = variables.find(name);
	
	if (iter == variables.end())
		throw TGen::RuntimeException("VariablesRegistry::getVariable", "variable '" + name + "' does not exist");
	
	return iter->second;
}

TGen::Engine::Variable & TGen::Engine::VariablesRegistry::getVariable(const std::string & name) {
	VariableMap::iterator iter = variables.find(name);
	
	if (iter == variables.end())
		throw TGen::RuntimeException("VariablesRegistry::getVariable", "variable '" + name + "' does not exist");
	
	return iter->second;	
}

TGen::Engine::VariablesRegistry & TGen::Engine::VariablesRegistry::addVariable(const TGen::Engine::Variable & variable, uint flags) {
	VariableMap::iterator iter = variables.find(variable.getName());
	
	if (iter != variables.end()) {	// TODO: check whether the variable has a "remove on new"-flag
		if (flags & TGen::Engine::AddOverrideDefaults)
			iter->second.takeDefaults(variable);

		if (flags & TGen::Engine::AddOverrideValue)
			iter->second = variable.getValue();
		
		if (flags & TGen::Engine::AddNoThrow)
			return *this;
		else 
			throw TGen::RuntimeException("VariablesRegistry::addVariable", "variable '" + variable.getName() + "' already exists");
	}
	
	variables.insert(VariableMap::value_type(variable.getName(), variable));
	
	return *this;
}



const TGen::Engine::Variable & TGen::Engine::VariablesRegistry::operator [] (const std::string & name) const {
	return getVariable(name);
}

TGen::Engine::Variable & TGen::Engine::VariablesRegistry::operator [] (const std::string & name) {
	return getVariable(name);
}

TGen::Engine::VariablesRegistry & TGen::Engine::VariablesRegistry::operator += (const TGen::Engine::Variable & var) {
	return addVariable(var);
}

void TGen::Engine::VariablesRegistry::getVariables(std::vector<std::string> & vars) {
	VariableMap::iterator iter = variables.begin();
	for (; iter != variables.end(); ++iter)
		vars.push_back(iter->first);
}

void TGen::Engine::VariablesRegistry::dumpVariables(TGen::Engine::Filesystem & fs) {
	TGen::Engine::File * file = fs.openWrite("vardump");
	if (!file)
		throw TGen::RuntimeException("VariablesRegistry::dumpVariables", "failed to open file for writing");
	
	std::string header = "// this file is autogenerated and will be overwritten.\n";
	file->write(header.c_str(), header.size(), 1);
		
	VariableMap::const_iterator iter = variables.begin();
	for (; iter != variables.end(); ++iter) {
		if (iter->second.getFlags() & TGen::Engine::VariableDump) {
			std::stringstream ss;
			ss << "set \"" << iter->second.getName() << "\" " << "\"" << iter->second.getValue() << "\"\n";
			file->write(ss.str().c_str(), ss.str().size(), 1);
		}
	}
	
	delete file;
}
